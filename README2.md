### Ідея 
Цей код використовує **асинхронне програмування** на основі `CompletableFuture`, щоб розподілити обчислювальні завдання між потоками в пулі. Основні кроки:

1. **Створення пулу потоків (`ExecutorService`)**:
    - Задається пул з двома потоками (`Executors.newFixedThreadPool(2)`).
    - Пул дозволяє обробляти завдання асинхронно, щоб головний потік не блокувався.

2. **Генерація чисел асинхронно**:
    - `CompletableFuture.supplyAsync` використовується для асинхронного створення списку випадкових чисел.
    - Генерація відбувається в окремому потоці, щоб не блокувати головний потік.

3. **Обчислення результату асинхронно**:
    - `thenApplyAsync` дозволяє застосувати функціонал обчислення на основі згенерованих чисел.
    - Логіка обчислення: обчислюється добуток різниць між послідовними елементами масиву чисел.

4. **Завершальні дії**:
    - `thenRunAsync` використовується для виведення завершальних повідомлень, а також вимкнення пулу потоків (`es.shutdown()`) після завершення всіх завдань.

5. **Синхронний очікувальний виклик**:
    - `generateNums.join()` гарантує, що головний потік дочекається завершення обчислень перед завершенням програми.

---

### Що відбувається по кроках?

1. **Генерація випадкових чисел** (`supplyAsync`):
    - Створюється список з трьох випадкових чисел.

2. **Обчислення асинхронно** (`thenApplyAsync`):
    - Рахується добуток різниць між кожною парою чисел у списку.

3. **Виведення результату** (`thenAcceptAsync`):
    - Після обчислень виводиться результат.

4. **Виведення інформації про завершення** (`thenRunAsync`):
    - Повідомлення про завершення завдання та час виконання програми.


### Переваги використання `CompletableFuture`
1. **Асинхронність**: Завдання виконуються у фонових потоках.
2. **Ефективність**: Можливість використовувати кілька потоків для паралельних завдань.
3. **Легкість у підтримці**: Ланцюжки методів роблять код чистішим і більш читабельним.
